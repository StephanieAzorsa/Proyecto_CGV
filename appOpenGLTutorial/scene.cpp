#include <QMatrix4x4>
#include "scene.h"

using namespace std;
//Muestra la ventana de OpenGl donde se dibuja, es la escena donde se muestra las formas

//Cconstructor que hereda las características de OpenGL
Scene::Scene( QWidget *parent ) : QOpenGLWidget( parent )
{
    //Entiendo que acá debemos crear todas las figuras
    this->setFocusPolicy( Qt::StrongFocus );
    sphere = new Sphere(25); //Se instancia un objeto de la clase esfera
    cube = new Cube(25);
    shape = 1;
}

//Destructor de la clase
Scene::~Scene()
{
      delete sphere;
      delete cube;
}

//Sirve para realizar la inicialización de recursos OpenGL
void Scene::initializeGL()
{
    //Esta clase es un contenedor para funciones del perfil principal de OpenGL 4.0
    //Devuelve un puntero a un objeto que proporciona acceso a todas las funciones
    //para la versión y perfil en el contexto actual(currentContext).
    QOpenGLFunctions_4_0_Core *f = QOpenGLContext::currentContext()->versionFunctions<QOpenGLFunctions_4_0_Core>();

    //f-> es un operador para el acceso de miembros de un objeto,
    //    en este caso se esta accediendo a funciones de OpenGl 4.0
    f->glClearColor( 0.1f, 0.1f, 0.2f, 1.0f ); //Da el color a la ventana
    f->glGenVertexArrays(1,VAOs); // parámetros: (#VAOs, VAOs)
    f->glGenBuffers(1,VBOs);

    //Acá hago un switch para cambiar entre los datos de la figura
   // vector<int> ind = sphere->getIndices(); //Se obtiene el arreglo de indices de los vértices de la esfera
   // vector<QVector3D> vert = sphere->getVertices(); //Retorna todos los puntos de la esfera en un arreglo de 3
   // vector<float> pvalues; //Se guarda los verdices retornados
    vector<int> ind;
    vector<QVector3D> vert;
    vector<float> pvalues;
    int numIndices;

    switch (shape) {
        case 1:
        ind = sphere->getIndices(); //Se obtiene el arreglo de indices de los vértices de la esfera
        vert = sphere->getVertices(); //Retorna todos los puntos de la esfera en un arreglo de 3
        numIndices = sphere->getNumIndices();
        break;
        case 2:
        ind = sphere->getIndices(); //Se obtiene el arreglo de indices de los vértices de la esfera
        vert = sphere->getVertices(); //Retorna todos los puntos de la esfera en un arreglo de 3
        numIndices = sphere->getNumIndices();
          qWarning( "F2 init" );
        break;
    }



   // int numIndices = sphere->getNumIndices(); //Obtiene el número de índices, el tamaño, la cantidad

    //Para obtener los puntos de los vectores en 3D y guardar cada punto en un arreglo de tipo float
    for (int i = 0; i < numIndices; i++) {
        pvalues.push_back((vert[ind[i]]).x());
        pvalues.push_back((vert[ind[i]]).y());
        pvalues.push_back((vert[ind[i]]).z());
    }

    //VAOs for SPHERE
    f->glBindVertexArray(VAOs[0]); //Enlaza el VAO
    f->glBindBuffer(GL_ARRAY_BUFFER,VBOs[0]); //Enlaza el VBO

    //Se especifica el tamaño y se manda como parámetro el tamaño y la cantidad
    //total de puntos al buffer de datos
    f->glBufferData(GL_ARRAY_BUFFER,pvalues.size()*4, &pvalues[0], GL_STATIC_DRAW);

    //Describe cómo se distribuyen los datos, ya que los datos están vinculados a GL_ARRAY_BUFFER
    //y este descriptor se guarda en nuestra matriz de vértices
    f->glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3*sizeof(float),(void*)0);

    //habilita el índice de atributo para el atributo de posición.
    //Si el atributo no está habilitado, no se utilizará durante el renderizado.
    f->glEnableVertexAttribArray(0); //0: Indice de los vértices, 1: colores, se definen los demás, ejm: 2: textura, 3:normal

    /**/
    //QOpenGLShader y QOpenGLShaderProgram protejen al programador de los detalles de compilar y vincular shaders y fragmentos*/
    QOpenGLShader vShader( QOpenGLShader::Vertex ); //Admite programas de shader, escritos en el lenguje GLSL
    vShader.compileSourceFile( ":/shaders/vertexShader.glsl" );

    QOpenGLShader fShader( QOpenGLShader::Fragment );
    fShader.compileSourceFile( ":/shaders/fragmentShader.glsl" );

    m_program.addShader( &vShader ); //Agrega un sahder compilado a este programa, método booleano
    m_program.addShader( &fShader ); //devuelve true y se puede agregar el shader o falso en caso contrario

    //Sirve para enlazar shaders
    //bool QOpenGLShaderProgram :: link (), Vincula los shaders que se agregaron a este programa con addShader ().
    //Devuelve truesi el enlace fue exitoso o falso en caso contrario.
    //Si el enlace falló, los mensajes de error se pueden recuperar con log ().
    if ( !m_program.link() )
    {
        qWarning( "Error: unable to link a shader program." );
        return;
    }
    /**/

    //attributeLocation: Devuelve la ubicación del nombre del atributo dentro de la lista de parámetros de este programa de shaders.
    //Devuelve -1 si el nombre no es un atributo válido para este programa de sombreado.
    m_vertexAttr = m_program.attributeLocation( "vertexAttr" ); //vertexAttr nombre del atributo dentro de la lista de parámetros del archivo VertexShader
    //m_colorAttr = m_program.attributeLocation( "colorAttr" ); //manda e atributo para los colores

    //uniformLocation: devuelve la locación del nombre de la variabe uniforme dentro de la lista de parámetros de este programa
    //devuelve -1, si la variable no fue encontrada
    m_matrixUniform = m_program.uniformLocation( "matrix" );

    //Se instancia un objeto de la clase Triangle
    //m_triangle = new Triangle( &m_program, m_vertexAttr, m_colorAttr );
}

//Renderiza las imágenes o formas
void Scene::paintGL()
{
    QOpenGLFunctions_4_0_Core *f = QOpenGLContext::currentContext()->versionFunctions<QOpenGLFunctions_4_0_Core>();
    f->glClear( GL_COLOR_BUFFER_BIT );

    //bind: vincula el programa de shader al contexto actual, y lo convierte al porgrama de shader actual
    //Es equivalente a llamar al glUseProgram()
    if ( !m_program.bind() )
        return;

    QMatrix4x4 matrix; //se declara la matrix

    matrix.ortho( -8.0f, 8.0f, -8.0f, 8.0f, 8.0f, -8.0f ); //Para la cámara
    matrix.translate( 0.0f, 0.0f, 0.0f ); //Mover la forma renderizada al origen
    //matrix.perspective();

    //Para las rotaciones en el eje x, y, z
    matrix.rotate(float(rotateX), 1.0f, 0.0f, 0.0f);
    matrix.rotate(float(rotateY), 0.0f, 1.0f, 0.0f);
    matrix.rotate(float(rotateZ), 0.0f, 0.0f, 1.0f);

    //setUniformValue: establece la variable uniform en la ubicación en el contexto actual
    m_program.setUniformValue( m_matrixUniform, matrix ); //Permite la asignación de las operaciones de transformación y asignarlas al shader

    //m_triangle->draw();
    f->glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); //controla la interpretación de polígonos, la forma en que se muestra el renderizado, en este caso un renderizado de líneas
    f->glBindVertexArray(VAOs[0]);
    switch(shape){
        case 1:
        f->glDrawArrays(GL_TRIANGLES, 0, sphere->getNumIndices());
        break;
        case 2:
        f->glDrawArrays(GL_TRIANGLES, 0, sphere->getNumIndices());
          qWarning( "F2 paint" );
        break;
    }
    //f->glDrawArrays(GL_TRIANGLES, 0, sphere->getNumIndices());

    m_program.release(); //libera el programa del shader activo del contexto actual
}

//Sirve para configurar las matrices de transformación y otros recursos dependientes del tamaño de la ventana
void Scene::resizeGL( int w, int h )
{
    QOpenGLFunctions_4_0_Core *f = QOpenGLContext::currentContext()->versionFunctions<QOpenGLFunctions_4_0_Core>();

    f->glViewport( 0, 0, w, h ); //Marca la región sobre la cual se quiere dibujar nuestras formas
    //Tiene como parámetro las dimensiones de la ventada donde se va a dibujar diferentes escenas de un mismo objeto
    //o con un mismo objeto
}


//Métodos de acceso de los atributos privados para realizar las rotaciones, en las 3 direcciones
void Scene::setRotateX(float x){rotateX=x;}
void Scene::setRotateY(float y){rotateY=y;}
void Scene::setRotateZ(float z){rotateZ=z;}
float Scene::getRotateX()const{return rotateX;}
float Scene::getRotateY()const{return rotateY;}
float Scene::getRotateZ()const{return rotateZ;}

//Con esto deberíamos cambiar las formas
void Scene::setShape(int x){ shape = x;}
int Scene::getShape()const{return shape;}
